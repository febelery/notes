## 概念

每一个变量都会分配一块内存，数据保存在内存中，内存有一个地址，就像门牌号，通过这个地址就可以找到里面存储的数据。指针就是保存这个内存地址的变量。

指针是类型安全的。Go 还有非类型安全的指针，这就是 unsafe 包提供的 `unsafe.Pointer`。

- `&`符号的意思是对变量取地址，如：变量`a`的地址是`&a`
- `*`符号的意思是对指针取值，如:`*&a`，就是`a`变量所在地址的值，当然也就是`a`的值了

- `*`和 `&` 可以互相抵消,同时注意，`*&`可以抵消掉，但`&*`是不可以抵消的

```go
	i := 10
	ip := &i

	fmt.Println(i, &i, ip, &ip, *ip)
```

```
10 0xc000128258 0xc000128258 0xc00012c030 10
```



### 应用场景

1. Go语言中除了map、slice、chan外，其他类型在函数参数中都是值传递
2. Go语言不是面向对象的语言，很多时候实现结构体方法时需要用指针类型实现引用结构体对象
3. 指针也是一个类型，在实现接口`interface`时，结构体类型和其指针类型对接口的实现是不同的

### 限制

1. 不能进行数学运算

2. 不同类型的指针不能相互转换

3. 不同类型的指针不能使用==或!=比较

   只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 `==` 和 `!=` 直接和 `nil` 作比较。
   
4. 不同类型的指针变量不能相互赋值





## 值传递

函数传递的总是原来这个东西的一个副本，一副拷贝。

比如我们传递一个`int`类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。

Go语言是没有引用传递的。

Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。



> 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。



## 值接收者和指针接收者何时使用

使用指针作为方法的接收者的理由：**方法能够修改接收者指向的值**

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的`本质`

- 使用值接收者，类型具备“原始的本质”
  - Go 语言里内置的原始类型 ，如字符串，整型值等
  - 内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 `header`， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 `header`，而 `header` 本身就是为复制设计的。
- 使用指针接收者，类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份`实体`



## 逃逸分析

分析指针动态范围的方法称之为`逃逸分析`。

当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。

一个变量是在堆上分配，还是在栈上分配，是经过编译器的`逃逸分析`之后得出的结论。



> 如果一个函数返回对一个变量的引用，那么它就会发生逃逸
>
> 如果函数外部没有引用，则优先放到栈中；如果函数外部存在引用，则必定放到堆中；



编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。



- 堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收（GC）才能释放，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）
- 栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASSE”，分配和释放。栈可以自动清理



```go
func foo() *int {
	t := 3
	return &t // moved to heap: t
}

func main() {
	x := foo()
	fmt.Println(*x) // *x escapes to heap fmt.Println(a ...interface{}),函数参数为interface类型，编译期间很难确定其参数的具体类型，也会发生逃逸
}
```

```shell
go build -gcflags '-m -l' main.go
```



堆上动态分配内存比栈上静态分配内存，开销大很多。不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。

