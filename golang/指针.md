## 概念

- *类型: 普通指针类型，用于传递对象地址，不能进行指针运算。
- `unsafe.Pointer`: 通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。
- `uintptr`: 用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。

`unsafe.Pointer` 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算，`unsafe.Pointer` 不能参与指针运算。

`unsafe.Pointer` 可以让你的变量在不同的普通指针类型转来转去，也就是表示为任意可寻址的指针类型。而 `uintptr` 常用于与 `unsafe.Pointer` 打配合，用于做指针运算。

不可以直接通过*p来获取`unsafe.Pointer`指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，`unsafe.Pointer`指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。

每一个变量都会分配一块内存，数据保存在内存中，内存有一个地址，就像门牌号，通过这个地址就可以找到里面存储的数据。指针就是保存这个内存地址的变量。

指针是类型安全的。Go 还有非类型安全的指针，这就是 unsafe 包提供的 `unsafe.Pointer`。

- `&`符号的意思是对变量取地址，如：变量`a`的地址是`&a`
- `*`符号的意思是对指针取值，如:`*&a`，就是`a`变量所在地址的值，当然也就是`a`的值了

- `*`和 `&` 可以互相抵消,同时注意，`*&`可以抵消掉，但`&*`是不可以抵消的

```go
i := 10
ip := &i

fmt.Println(i, &i, ip, &ip, *ip)
```

```
10 0xc000128258 0xc000128258 0xc00012c030 10
```

### new  和 make

- new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针
- make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了



### 应用场景

1. Go语言中除了map、slice、chan外，其他类型在函数参数中都是值传递
2. Go语言不是面向对象的语言，很多时候实现结构体方法时需要用指针类型实现引用结构体对象
3. 指针也是一个类型，在实现接口`interface`时，结构体类型和其指针类型对接口的实现是不同的

### 限制

1. 不能进行数学运算

2. 不同类型的指针不能相互转换

3. 不同类型的指针不能使用==或!=比较

   只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 `==` 和 `!=` 直接和 `nil` 作比较。
   
4. 不同类型的指针变量不能相互赋值



## 值传递

函数传递的总是原来这个东西的一个副本，一副拷贝。

比如我们传递一个`int`类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。

Go语言是没有引用传递的。

Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。

> 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。



## 值接收者和指针接收者何时使用

使用指针作为方法的接收者的理由：**方法能够修改接收者指向的值**

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的`本质`

- 使用值接收者，类型具备“原始的本质”
  - Go 语言里内置的原始类型 ，如字符串，整型值等
  - 内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 `header`， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 `header`，而 `header` 本身就是为复制设计的。
- 使用指针接收者，类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份`实体`
- 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间



## 逃逸分析

分析指针动态范围的方法称之为`逃逸分析`。

当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。

一个变量是在堆上分配，还是在栈上分配，是经过编译器的`逃逸分析`之后得出的结论。



> 如果一个函数返回对一个变量的引用，那么它就会发生逃逸
>
> 如果函数外部没有引用，则优先放到栈中；如果函数外部存在引用，则必定放到堆中；



编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。



- 堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收（GC）才能释放，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）
- 栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASSE”，分配和释放。栈可以自动清理



```go
func foo() *int {
	t := 3
	return &t // moved to heap: t
}

func main() {
	x := foo()
	fmt.Println(*x) // *x escapes to heap fmt.Println(a ...interface{}),函数参数为interface类型，编译期间很难确定其参数的具体类型，也会发生逃逸
}
```

```shell
go build -gcflags '-m -l' main.go
```



堆上动态分配内存比栈上静态分配内存，开销大很多。不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。





## Unsafe

### Pointer

`unsafe.Pointer`表示任意类型且可寻址的指针值，可以在不同的指针类型之间进行转换

- 任何类型的指针值都可以转换为 Pointer
- Pointer 可以转换为任何类型的指针值
- uintptr 可以转换为 Pointer
- Pointer 可以转换为 uintptr



通过地址改变值

```go
str := ""
// 获得该字符串的地址
p := uintptr(unsafe.Pointer(&str))
// 在该地址上赋值
*(*string)(unsafe.Pointer(p))="test"
fmt.Println(str)
```

